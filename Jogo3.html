<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jogo de Carro ‚Äî Primeira Pessoa</title>
  <style>
    :root {
      --bg: #0b0e13;
      --fg: #e8eef6;
      --accent: #68d391;
      --danger: #ff6b6b;
      --muted: #94a3b8;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 600px at 50% -200px, #1a2232, var(--bg));
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
    }
    .wrap {
      display: grid;
      grid-template-rows: auto 1fr auto;
      height: 100%;
    }
    header, footer {
      text-align: center;
      padding: .75rem 1rem;
      opacity: .9;
    }
    header h1 {
      font-size: clamp(1rem, 2vw, 1.2rem);
      font-weight: 600;
      letter-spacing: .5px;
      margin: 0;
    }
    #hud {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: grid;
      grid-template-columns: 1fr 1fr;
      padding: 12px;
      font-weight: 600;
      mix-blend-mode: screen;
      text-shadow: 0 2px 8px rgba(0,0,0,.6);
    }
    .stat { opacity:.95; }
    .stat.right { text-align: right; }
    #game {
      position: relative;
      display: grid;
      place-items: center;
    }
    canvas { 
      width: min(900px, 100vw);
      height: calc(min(900px, 100vw) * 0.6);
      max-height: 80vh;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,.5);
      background: linear-gradient(#243042, #10151d 60%);
    }
    .overlay {
      position:absolute; inset:0; display:grid; place-items:center;
      /* Removido pointer-events:none para permitir clique no bot√£o */
      text-align:center; padding: 1rem;
    }
    .card {
      display:inline-block; background:rgba(16,21,29,.75); border:1px solid rgba(255,255,255,.08);
      padding:16px 20px; border-radius:14px; backdrop-filter: blur(6px);
    }
    .title { font-size: 1.25rem; margin: 0 0 .5rem; }
    .btns { display:flex; gap:.5rem; justify-content:center; margin-top:.75rem; }
    .btn { pointer-events:auto; border:1px solid rgba(255,255,255,.15); background:#0f1722; color:var(--fg);
      padding:.6rem .9rem; border-radius: 10px; cursor:pointer; font-weight:600; }
    .btn:focus { outline:2px solid var(--accent); }
    .hint { color: var(--muted); font-size:.9rem }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>üöó Jogo de Carro ‚Äî Desvie em Primeira Pessoa (JS)</h1>
    </header>

    <main id="game">
      <canvas id="canvas" aria-label="Pista de corrida"></canvas>
      <div id="hud">
        <div class="stat" id="score">Pontos: 0</div>
        <div class="stat right" id="speed">Velocidade: 0</div>
      </div>
      <div class="overlay" id="overlay">
        <div class="card">
          <h2 class="title">Pronto pra correr?</h2>
          <div class="hint">Setas ou A/D para mover ‚Ä¢ Espa√ßo para pausar ‚Ä¢ R para reiniciar ‚Ä¢ Toque/Arraste no celular</div>
          <div class="btns">
            <button class="btn" id="startBtn">Come√ßar</button>
          </div>
        </div>
      </div>
    </main>

    <footer>
      Feito em JavaScript + Canvas. Sem bibliotecas externas.
    </footer>
  </div>

<script>
(function(){
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const hudScore = document.getElementById('score');
  const hudSpeed = document.getElementById('speed');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');

  // Ajuste para alta densidade de pixels
  function fitCanvas(){
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // desenhar em coordenadas CSS
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // Mundo b√°sico em "1.5D": usamos uma pista em perspectiva e obst√°culos que se aproximam.
  const state = {
    running:false,
    paused:false,
    score:0,
    time:0,
    speed: 22,          // unidades por segundo (z por segundo)
    topSpeed: 80,
    accel: 0.25,        // acelera√ß√£o leve ao longo do tempo
    laneWidth: 2.4,     // largura em metros de uma faixa imagin√°ria
    roadWidth: 3 * 2.4, // 3 faixas
    fov: 100,           // campo de vis√£o ("c√¢mera")
    camZ: 1.2,
    playerX: 0,         // posi√ß√£o lateral do jogador em metros (0 = centro)
    targetX: 0,
    obstacles: [],
    laneMarkers: [],
    lastSpawn: 0,
    spawnEvery: 0.9,    // segundos
  };

  // Utilidades
  function rand(min,max){ return Math.random()*(max-min)+min; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  // Proje√ß√£o simples perspectiva -> tela
  function project(x, z){
    const vpX = canvas.clientWidth/2;
    const vpY = canvas.clientHeight*0.72; // horizonte mais alto
    const scale = state.fov / (z + state.camZ);
    const screenX = vpX + x * scale * 60; // 60 = fator de pixels por metro (ajuste fino)
    const screenY = vpY - scale * 120;    // 120 = altura do "ch√£o" em pixels
    const width  = scale * 140;           // largura base do objeto (carros)
    return {x:screenX, y:screenY, scale, width};
  }

  // Criar marcadores de faixa que se movem
  function initLaneMarkers(){
    state.laneMarkers.length = 0;
    for(let i=0;i<30;i++){
      state.laneMarkers.push({ z: i*3, len: 1.2 });
    }
  }

  // Spawn de "carros"/obst√°culos √† frente
  function spawnObstacle(){
    const lanes = [-state.roadWidth/3, 0, state.roadWidth/3];
    const x = lanes[(Math.random()*lanes.length)|0];
    const z = rand(25, 55);
    const w = 1.8, h = 1; // dimens√µes abstratas
    const color = Math.random()<0.5 ? '#ffce54' : '#5cc8ff';
    state.obstacles.push({x, z, w, h, color});
  }

  function reset(){
    state.running = true;
    state.paused = false;
    state.score = 0;
    state.time = 0;
    state.speed = 22;
    state.obstacles = [];
    state.lastSpawn = 0;
    initLaneMarkers();
    for(let i=0;i<6;i++) spawnObstacle();
  }

  // Inputs
  const keys = new Set();
  window.addEventListener('keydown', (e)=>{
    if(['ArrowLeft','ArrowRight','a','d','A','D'].includes(e.key)) e.preventDefault();
    keys.add(e.key);
    if(e.key===' '){ togglePause(); }
    if(e.key==='r' || e.key==='R'){ start(); }
  });
  window.addEventListener('keyup', (e)=> keys.delete(e.key));

  // Controles por toque/arraste
  let dragging = false, lastClientX = null;
  canvas.addEventListener('pointerdown', (e)=>{ dragging=true; lastClientX=e.clientX; canvas.setPointerCapture(e.pointerId); });
  canvas.addEventListener('pointerup',   (e)=>{ dragging=false; lastClientX=null; });
  canvas.addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    const dx = e.clientX - lastClientX; lastClientX = e.clientX;
    state.targetX += (dx / canvas.clientWidth) * state.roadWidth * 0.9; // arraste proporcional
    state.targetX = clamp(state.targetX, -state.roadWidth*0.48, state.roadWidth*0.48);
  });

  // Pausa
  function togglePause(){
    if(!state.running) return;
    state.paused = !state.paused;
  }

  function start(){
    overlay.style.display='none';
    reset();
  }
  startBtn.addEventListener('click', start);

  // Loop
  let last = performance.now();
  function tick(now){
    const dt = Math.min((now - last)/1000, 0.05);
    last = now;

    if(state.running && !state.paused){
      update(dt);
      draw();
    } else {
      draw(); // ainda desenha overlay/pista
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  function update(dt){
    state.time += dt;
    state.speed = clamp(state.speed + state.accel*dt, 0, state.topSpeed);

    // Input teclado -> alvo lateral
    const left = keys.has('ArrowLeft') || keys.has('a') || keys.has('A');
    const right= keys.has('ArrowRight')|| keys.has('d') || keys.has('D');
    if(left) state.targetX -= 5 * dt;
    if(right)state.targetX += 5 * dt;

    // Limites laterais
    state.targetX = clamp(state.targetX, -state.roadWidth*0.48, state.roadWidth*0.48);

    // Suavizar movimento do carro (interp)
    state.playerX += (state.targetX - state.playerX) * Math.min(10*dt, 1);

    // Avan√ßo do mundo: obst√°culos e marcadores aproximam (z diminui)
    const advance = state.speed * dt * 0.9; // "metros" por dt

    for(const seg of state.laneMarkers){
      seg.z -= advance;
      if(seg.z < -1) { seg.z += 30*3; } // reaproveita mais √† frente
    }

    for(const obs of state.obstacles){
      obs.z -= advance;
    }

    // Remover obst√°culos passados e spawnar novos
    state.obstacles = state.obstacles.filter(o => o.z > 0.5);
    state.lastSpawn += dt;
    if(state.lastSpawn >= state.spawnEvery){
      state.lastSpawn = 0;
      if(state.obstacles.length < 12) spawnObstacle();
    }

    // Pontua√ß√£o por tempo/velocidade
    state.score += state.speed * dt * 0.25;

    // Checar colis√£o: quando obst√°culo est√° perto (z pequeno), comparar lateral
    for(const o of state.obstacles){
      if(o.z < 4){
        const lateralGap = Math.abs(o.x - state.playerX);
        const safeGap = 0.9; // toler√¢ncia lateral
        if(lateralGap < safeGap){
          gameOver();
          break;
        }
      }
    }

    // HUD
    hudScore.textContent = `Pontos: ${Math.floor(state.score)}`;
    hudSpeed.textContent = `Velocidade: ${Math.round(state.speed)}`;
  }

  function gameOver(){
    state.running = false;
    overlay.style.display='grid';
    overlay.querySelector('.title').textContent = 'Bateu!';
    overlay.querySelector('.hint').textContent = `Voc√™ fez ${Math.floor(state.score)} pontos. Pressione R para reiniciar.`;
    startBtn.textContent = 'Jogar de novo';
  }

  function draw(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // C√©u
    const skyGrad = ctx.createLinearGradient(0,0,0,h*0.6);
    skyGrad.addColorStop(0,'#1d2840');
    skyGrad.addColorStop(1,'#10151d');
    ctx.fillStyle = skyGrad; ctx.fillRect(0,0,w,h);

    // Pista (trapezoidal) com bordas
    const vpX = w/2, horizon = h*0.35;
    const roadBottom = h*0.95;
    const roadHalfTop = 40; // metade superior estreita
    const roadHalfBottom = w*0.42; // abre embaixo

    // Bordas
    ctx.fillStyle = '#2b364a';
    ctx.beginPath();
    ctx.moveTo(vpX-roadHalfTop-14, horizon);
    ctx.lineTo(vpX-roadHalfBottom-20, roadBottom);
    ctx.lineTo(vpX+roadHalfBottom+20, roadBottom);
    ctx.lineTo(vpX+roadHalfTop+14, horizon);
    ctx.closePath();
    ctx.fill();

    // Asfalto
    ctx.fillStyle = '#151b27';
    ctx.beginPath();
    ctx.moveTo(vpX-roadHalfTop, horizon);
    ctx.lineTo(vpX-roadHalfBottom, roadBottom);
    ctx.lineTo(vpX+roadHalfBottom, roadBottom);
    ctx.lineTo(vpX+roadHalfTop, horizon);
    ctx.closePath();
    ctx.fill();

    // Faixas laterais
    ctx.strokeStyle = '#c7d2fe';
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.moveTo(vpX-roadHalfTop, horizon);
    ctx.lineTo(vpX-roadHalfBottom, roadBottom);
    ctx.moveTo(vpX+roadHalfTop, horizon);
    ctx.lineTo(vpX+roadHalfBottom, roadBottom);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Marcadores de faixa animados (linhas pontilhadas centrais)
    for(const seg of state.laneMarkers){
      const z = seg.z;
      const mid = project(0, z);
      const half = (mid.width * 0.08);
      const y1 = mid.y + 20 * mid.scale;
      const y2 = y1 + 60 * mid.scale * seg.len;
      ctx.strokeStyle = 'rgba(255,255,255,.8)';
      ctx.lineWidth = Math.max(2, half*0.9);
      ctx.beginPath();
      ctx.moveTo(vpX - ctx.lineWidth*0.5, y1);
      ctx.lineTo(vpX - ctx.lineWidth*0.5, y2);
      ctx.stroke();
    }

    // Obst√°culos (carros que v√™m)
    for(const o of [...state.obstacles].sort((a,b)=>b.z-a.z)){
      const p = project(o.x, o.z);
      if(p.y > h) continue;

      const carW = p.width * 0.6;
      const carH = 28 * p.scale + 8;
      const x = p.x - carW/2;
      const y = p.y + 20 * p.scale;

      // sombra
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      ctx.beginPath();
      ctx.ellipse(p.x, y+carH+2, carW*0.55, carH*0.25, 0, 0, Math.PI*2);
      ctx.fill();

      // carro
      ctx.fillStyle = o.color;
      roundRect(ctx, x, y, carW, carH, 6);
      ctx.fill();

      // detalhes
      ctx.fillStyle = '#222';
      roundRect(ctx, x+carW*0.1, y+carH*0.15, carW*0.8, carH*0.2, 4); // para-brisa
      ctx.fill();
      ctx.fillStyle = '#eee';
      roundRect(ctx, x+carW*0.08, y+carH*0.72, carW*0.2, carH*0.18, 3); // farol esq
      roundRect(ctx, x+carW*0.72, y+carH*0.72, carW*0.2, carH*0.18, 3); // farol dir
    }

    // Carro do jogador (HUD/volante minimalista)
    drawCockpit();
    if(state.paused){ drawPause(); }
  }

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function drawCockpit(){
    const w = canvas.clientWidth, h = canvas.clientHeight;

    // Volante simplificado
    const cx = w/2, cy = h*0.92, R = Math.min(w,h)*0.13;
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#0d1420';
    ctx.beginPath();
    ctx.arc(cx, cy, R, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Indicador de posi√ß√£o lateral (barra)
    const roadHalfBottom = w*0.42;
    const norm = (state.playerX / (state.roadWidth*0.48));
    const barW = 160, barH = 7;
    const bx = cx - barW/2, by = cy - R - 16;
    ctx.fillStyle = 'rgba(255,255,255,.15)';
    roundRect(ctx, bx, by, barW, barH, 4); ctx.fill();
    ctx.fillStyle = '#7cdd9b';
    const knobX = bx + (norm*0.5+0.5)* (barW - 14);
    roundRect(ctx, knobX, by-3, 14, barH+6, 5); ctx.fill();
  }

  function drawPause(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    ctx.fillRect(0,0,w,h);
    ctx.fillStyle = '#fff';
    ctx.font = '700 28px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('PAUSADO', w/2, h/2);
    ctx.font = '500 14px system-ui';
    ctx.fillText('Pressione espa√ßo para continuar', w/2, h/2 + 24);
  }
})();
</script>
</body>
</html>
