<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Carros na Pista</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    #hud {
      position: absolute;
      top: 10px; left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-family: Arial, sans-serif;
      font-weight: bold;
      color: #fff;
    }
    #score {
      font-size: 24px;
      color: #00ffcc;
      text-shadow: 0 0 10px #00ffcc, 0 0 20px #00ffaa;
    }
    #ammo, #lives {
      font-size: 20px;
      margin-top: 6px;
    }
    #gameOverScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.9);
      color: white;
      font-family: Arial, sans-serif;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 15px;
      font-size: 28px;
      z-index: 10;
    }
    #gameOverScreen h1 { font-size: 48px; margin: 0; color: #ff3333; }
    #gameOverScreen button {
      padding: 12px 24px;
      font-size: 20px;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: #ff3333;
      color: white;
    }
    #gameOverScreen button:hover { background: #cc0000; }
  </style>
</head>
<body>
  <div id="hud">
    <div id="score">Pontos: 0</div>
    <div id="ammo">Munição: 10</div>
    <div id="lives">Vidas: ❤️❤️❤️</div>
  </div>
  <div id="gameOverScreen">
    <h1>GAME OVER</h1>
    <p id="finalScore"></p>
    <button onclick="restartGame()">Reiniciar</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script>
    // --- CONFIG ---
    let score = 0;
    let lives = 3;
    let ammo = 10;
    let gameOver = false;
    let speed = 0.35;

    const scoreEl = document.getElementById("score");
    const ammoEl = document.getElementById("ammo");
    const livesEl = document.getElementById("lives");

    function updateHUD() {
      scoreEl.textContent = "Pontos: " + score;
      ammoEl.textContent = "Munição: " + ammo;
      livesEl.textContent = "Vidas: " + "❤️".repeat(lives);
    }

    function endGame() {
      gameOver = true;
      document.getElementById("gameOverScreen").style.display = "flex";
      document.getElementById("finalScore").textContent = "Pontuação final: " + score;
    }

    function restartGame() {
      window.location.reload();
    }

    // --- THREEJS SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
    scene.add(light);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(50, 100, 50);
    scene.add(dirLight);

    // Chão do deserto
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(1000, 1000),
      new THREE.MeshPhongMaterial({ color: 0xe0c97a })
    );
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // Estrada
    const roadWidth = 14;
    const road = new THREE.Mesh(
      new THREE.PlaneGeometry(roadWidth, 400, 1, 40),
      new THREE.MeshPhongMaterial({ color: 0x222222 })
    );
    road.rotation.x = -Math.PI/2;
    road.position.y = 0.02;
    road.position.z = -100;
    scene.add(road);

    // Faixas da pista
    const centerLines = [];
    for (let i=0; i<20; i++) {
      const line = new THREE.Mesh(
        new THREE.PlaneGeometry(1, 6),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
      );
      line.rotation.x = -Math.PI/2;
      line.position.set(0, 0.05, -i*20);
      scene.add(line);
      centerLines.push(line);
    }

    // Modelo do carro
    function createCar(color=0xff0000) {
      const car = new THREE.Group();
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(2.4, 0.5, 3.8),
        new THREE.MeshPhongMaterial({ color, flatShading: true })
      );
      body.position.y = 0.5;
      car.add(body);
      const cockpit = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 0.4, 1.2),
        new THREE.MeshPhongMaterial({ color: 0x222222, transparent: true, opacity: 0.85 })
      );
      cockpit.position.set(0, 0.8, -0.3);
      car.add(cockpit);
      return car;
    }

    // Jogador
    const car = createCar(0xff0000);
    car.position.set(0,0,5);
    scene.add(car);

    // Arrays
    let obstacles = [];
    let bullets = [];
    let pickups = [];
    const scenery = [];

    // Obstáculos
    function createObstacle() {
      const colors = [0x00ff00,0x0000ff,0xffff00,0xff00ff,0x00ffff];
      const c = createCar(colors[Math.floor(Math.random()*colors.length)]);
      c.position.set((Math.random()-0.5)*roadWidth*0.7, 0, -120);
      scene.add(c);
      obstacles.push(c);
    }

    // Pickup de munição
    function createPickup() {
      const sphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.5,16,16),
        new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0xaa0000 })
      );
      sphere.position.set((Math.random()-0.5)*roadWidth*0.8,0.5,-120);
      scene.add(sphere);
      pickups.push(sphere);
    }

    // Objetos no cenário
    function createPyramid(x,z) {
      const pyramid = new THREE.Mesh(
        new THREE.ConeGeometry(4,6,4),
        new THREE.MeshPhongMaterial({ color: 0xcc9966, flatShading:true })
      );
      pyramid.position.set(x,3,z);
      scene.add(pyramid);
      scenery.push({mesh:pyramid,speed:0.6});
    }
    function createCactus(x,z) {
      const cactus = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5,0.5,4,6),
        new THREE.MeshPhongMaterial({ color: 0x228b22 })
      );
      cactus.position.set(x,2,z);
      scene.add(cactus);
      scenery.push({mesh:cactus,speed:0.9});
    }
    for(let i=0;i<10;i++){
      createPyramid(-20-Math.random()*20,-i*50-50);
      createPyramid(20+Math.random()*20,-i*50-100);
      createCactus(-15,-i*30-40);
      createCactus(15,-i*35-60);
    }

    // Controles
    let left=false,right=false,shooting=false;
    document.addEventListener("keydown", e=>{
      if(e.key==="ArrowLeft") left=true;
      if(e.key==="ArrowRight") right=true;
      if(e.key===" ") shooting=true;
    });
    document.addEventListener("keyup", e=>{
      if(e.key==="ArrowLeft") left=false;
      if(e.key==="ArrowRight") right=false;
      if(e.key===" ") shooting=false;
    });

    // Jogo
    let velX=0;
    let obstacleCooldown=0;
    let pickupCooldown=500;

    function animate(){
      requestAnimationFrame(animate);
      if(gameOver) return;

      // Movimento lateral
      if(left) velX-=0.03;
      if(right) velX+=0.03;
      velX*=0.9;
      car.position.x+=velX;
      if(car.position.x<-roadWidth/2+1.5) car.position.x=-roadWidth/2+1.5;
      if(car.position.x>roadWidth/2-1.5) car.position.x=roadWidth/2-1.5;

      // Estrada
      road.position.z+=speed*2;
      if(road.position.z>0) road.position.z=-100;
      centerLines.forEach(line=>{
        line.position.z+=speed*2;
        if(line.position.z>20) line.position.z=-200;
      });

      // Obstáculos
      obstacleCooldown--;
      if(obstacleCooldown<=0){
        createObstacle();
        obstacleCooldown=100+Math.random()*80;
      }
      obstacles.forEach(o=>o.position.z+=speed*2);

      // Pickups
      pickupCooldown--;
      if(pickupCooldown<=0){
        createPickup();
        pickupCooldown=600+Math.random()*400;
      }
      pickups.forEach(p=>p.position.z+=speed*2);

      // Balas
      bullets.forEach(b=>{ b.position.z-=1.2; });
      bullets = bullets.filter(b=>{
        if(b.position.z<-150){ scene.remove(b); return false; }
        let hitIndex=-1;
        obstacles.forEach((o,idx)=>{
          if(Math.abs(b.position.x-o.position.x)<1.5 && Math.abs(b.position.z-o.position.z)<2){
            hitIndex=idx;
          }
        });
        if(hitIndex>=0){
          scene.remove(obstacles[hitIndex]);
          obstacles.splice(hitIndex,1);
          scene.remove(b);
          score+=5;
          updateHUD();
          return false;
        }
        return true;
      });

      // Colisão com carros
      obstacles = obstacles.filter(o=>{
        if(Math.abs(car.position.x-o.position.x)<1.6 && Math.abs(car.position.z-o.position.z)<2){
          lives--;
          updateHUD();
          scene.remove(o);
          if(lives<=0) endGame();
          return false;
        }
        return true;
      });

      // Colisão com pickups
      pickups = pickups.filter(p=>{
        if(Math.abs(car.position.x-p.position.x)<1.5 && Math.abs(car.position.z-p.position.z)<2){
          ammo+=5;
          updateHUD();
          scene.remove(p);
          return false;
        }
        return true;
      });

      // Tiro
      if(shooting && ammo>0){
        const bullet = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1,0.1,1,8),
          new THREE.MeshPhongMaterial({ color:0xff0000 })
        );
        bullet.rotation.x=Math.PI/2;
        bullet.position.set(car.position.x,0.5,car.position.z-2);
        scene.add(bullet);
        bullets.push(bullet);
        ammo--;
        updateHUD();
        shooting=false; // só 1 por tecla
      }

      // Movimento cenário
      scenery.forEach(obj=>{
        obj.mesh.position.z+=speed*obj.speed;
        if(obj.mesh.position.z>20) obj.mesh.position.z=-300-Math.random()*200;
      });

      // Velocidade
      speed+=0.00001;
      if(speed>1.0) speed=1.0;

      // Camera
      camera.position.set(car.position.x,4,car.position.z+8);
      camera.lookAt(car.position.x,0.5,car.position.z-5);

      renderer.render(scene,camera);
    }
    updateHUD();
    animate();

    window.addEventListener("resize",()=>{
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    });
  </script>
</body>
</html>
